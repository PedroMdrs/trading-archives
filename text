import React from "react";
import { HmacSHA256, enc } from "crypto-js";
import axios from "axios";
export const UserContext = React.createContext();

export const UserStorage = ({ children }) => {
  const [apiKey, setApiKey] = React.useState(null);
  const [apiSecret, setApiSecret] = React.useState(null);
  const [agroupedTrades, setAgroupedTrades] = React.useState([]);
  const [trades, setTrades] = React.useState([]);
  const [error, setError] = React.useState(null);
  const [loading, setLoading] = React.useState(false);
  let tradeAcc = [];
  let sortedTrades = [];
  let finalTrades = [];

  React.useEffect(() => {
    function processTradeData(tradesData) {
      tradesData.forEach((trade) => {
        // Create a new object with new properties
        const { symbol, side, commission, realizedPnl, qty } = trade;
        let findedTrade = sortedTrades.find((item) => {
          item.symbol === symbol;
        });
        if (!findedTrade) {
          findedTrade = {
            symbol,
            buyCommission: 0,
            sellCommission: 0,
            buyPnl: 0,
            sellPnl: 0,
            time: 0,
            uniqueId: null,
            side,
            qty: Number(qty),
          };
          sortedTrades.push(findedTrade);
        }
        if (side === "BUY") {
          findedTrade.buyCommission += parseFloat(commission) * -1;
          findedTrade.buyPnl += parseFloat(realizedPnl);
        } else if (side === "SELL") {
          findedTrade.sellCommission += parseFloat(commission) * -1;
          findedTrade.sellPnl += parseFloat(realizedPnl);
        }
        findedTrade.orderId = trade.orderId;
        findedTrade.totalCommission =
          findedTrade.sellCommission + findedTrade.buyCommission;
        findedTrade.totalPnl =
          findedTrade.sellPnl +
          findedTrade.buyPnl +
          findedTrade.totalCommission;
        findedTrade.time = trade.time;

        // Group up all trades that have same orderID in one object
        console.log(sortedTrades);
        let y = [];
        const groupedTrades = Object.values(
          sortedTrades.reduce((acc, trade, index) => {
            const previousTrade = index > 0 ? sortedTrades[index - 1] : null;
            const nextTrade =
              index !== sortedTrades[sortedTrades.length - 1]
                ? sortedTrades[index - 1]
                : null;
            if (!acc[trade.orderId]) {
              acc[trade.orderId] = { ...trade };
            } else if (
              acc[trade.orderId].side !== trade.side &&
              acc[trade.orderId].symbol === trade.symbol
            ) {
              acc[trade.orderId].totalPnl += trade.totalPnl;
              acc[trade.orderId].qty += Number(trade.qty);
              acc[trade.orderId].qty = Number(
                acc[trade.orderId].qty.toFixed(5)
              );
            } else if (
              acc[trade.orderId].side === trade.side &&
              acc[trade.orderId].orderId === trade.orderId
            ) {
              acc[trade.orderId].totalPnl += trade.totalPnl;
              acc[trade.orderId].qty += Number(trade.qty);
              acc[trade.orderId].qty = Number(
                acc[trade.orderId].qty.toFixed(5)
              );
            } else if (
              previousTrade !== null &&
              nextTrade !== null &&
              acc[trade.orderId].qty + nextTrade.qty === previousTrade.qty
            ) {
              acc[trade.orderId].side === trade.side;
              acc[trade.orderId].totalPnl += nextTrade.totalPnl;
            }
            return acc;
          }, {})
        );

        console.log(trades);
        // console.log(y);
        // Logic to identify a trade within groupedTrades array
        // let x = 0;
        // let symbolsacc = [];
        const final = Object.entries(
          groupedTrades.reduce(
            (acc, trade, index) => {
              let nextItem =
                index < groupedTrades.length - 1
                  ? groupedTrades[index + 1]
                  : null;
              let prevItem = index > 0 ? groupedTrades[index - 1] : null;

              if (
                groupedTrades[index - 2] !== undefined &&
                prevItem !== null &&
                nextItem !== null &&
                trade.symbol === nextItem.symbol &&
                trade.side !== nextItem.side &&
                trade.qty.toFixed(6) === nextItem.qty.toFixed(6) &&
                (trade.qty - prevItem.qty !== 0 ||
                  trade.qty === groupedTrades[index - 2].qty)
              ) {
                const uniqueId = trade.orderId + nextItem.orderId;
                acc[uniqueId] = { ...trade, uniqueId };
                acc[uniqueId].totalPnl += nextItem.totalPnl;
                acc[uniqueId].time = nextItem.time;
              } else if (
                prevItem === null &&
                nextItem !== null &&
                trade.symbol === nextItem.symbol &&
                trade.side !== nextItem.side &&
                trade.qty.toFixed(6) === nextItem.qty.toFixed(6)
              ) {
                const uniqueId = trade.orderId + nextItem.orderId;
                acc[uniqueId] = { ...trade, uniqueId };
                acc[uniqueId].totalPnl += nextItem.totalPnl;
                acc[uniqueId].time = nextItem.time;
              } else if (
                prevItem !== null &&
                nextItem !== null &&
                nextItem.side === trade.side &&
                nextItem.symbol === trade.symbol
              ) {
                if (nextItem.qty + trade.qty === prevItem.qty) {
                  acc[trade.orderId + prevItem.orderId] = { ...prevItem };
                }
                nextItem.qty + trade.qty === prevItem.qty
                  ? (acc[trade.orderId + prevItem.orderId].totalPnl +=
                      nextItem.totalPnl)
                  : "";
              } else if (
                prevItem !== null &&
                nextItem !== null &&
                nextItem.symbol !== trade.symbol &&
                prevItem.symbol !== trade.symbol
              ) {
                const uniqueId = trade.orderId;
                acc[uniqueId] = { ...trade, uniqueId };
              }
              return acc;
            },
            { totalQty: 0, side: null, time: null, totalPnl: 0 }
          )
        ).sort((a, b) => a.time - b.time);
        finalTrades = final
      });

      tradeAcc.push(...finalTrades);
      setAgroupedTrades(tradeAcc);
    }
    if (error === false) processTradeData(trades);
  }, [trades, error]);
  async function getFuturesTrades(apiKey, apiSecret, startTime, endTime) {
    const baseUrl = import.meta.env.VITE_REACT_API_URL;
    const endpoint = "/fapi/v1/userTrades";
    const headers = {
      "X-MBX-APIKEY": apiKey,
    };
    let tradesData = [];

    let timestamp = Date.now();
    const week = 1000 * 60 * 60 * 24 * 7;
    let period = Math.floor((endTime - startTime) / (1000 * 60 * 60 * 24 * 7));
    if (period === 0) period = 1;
    let i = 0;
    let shouldContinue = true;
    setApiKey(
      "rJDPs78HYBoZLk0STUZ8oyq4oThfZDvkROqHHvORakyJL7gaefguy8Y0e1JLnMeI"
    );
    setApiSecret(
      "kBpiwd8plBl1VO0c2JVrMbsvmaE7tSZJvCiKRwRU5BVHJmHFYVW2S5cekJFwJqFy"
    );
    while (i < period && shouldContinue) {
      timestamp = Date.now();
      const queryParams = `startTime=${startTime + i * week}&endTime=${
        i === 0 ? startTime + week : startTime + week + week * i
      }&timestamp=${timestamp}`;

      const signature =
        apiSecret && apiKey !== null
          ? HmacSHA256(queryParams, apiSecret).toString(enc.Hex)
          : "";

      const url = `${baseUrl}${endpoint}?${queryParams}&signature=${signature}`;
      setLoading(true);
      await axios
        .get(url, { headers })
        .then((response) => {
          if (response.data.length === 0) return;

          tradesData = [...tradesData, ...response.data];
          setError(false);
        })
        .catch((error) => {
          console.log(error);
          setError(true);
          setLoading(false);
          shouldContinue = false;
        });
      i++;
    }

    setTrades([...tradesData]);
    setLoading(false);
  }

  return (
    <UserContext.Provider
      value={{
        setApiKey,
        setApiSecret,
        apiKey,
        apiSecret,
        agroupedTrades,
        setAgroupedTrades,
        getFuturesTrades,
        error,
        loading,
        trades,
        setError,
        setLoading,
      }}
    >
      {children}
    </UserContext.Provider>
  );
};
